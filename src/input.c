#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

#include "lib/debug.h"
#include "input.h"

/******************************************************************************
 * CONSTANTS AND CONFIGURATION
 ******************************************************************************/

/* Maximum amount of lookahead. */
#define MAXLOOK 16

/* Maximum lexeme size. */
#define MAXLEX  1024

/* Number of lexemes in a single buffer. */
#define NUMLEX  3

/* Manipulate using NUMLEX. */
#define BUFSIZE ((MAXLEX * NUMLEX) + (2 * MAXLOOK))

/* Flush the buffer when "Next" passes this address. */
#define DANGER (End_buf - MAXLOOK)

/* Just past the last character in buf. */
#define END (&Start_buf[BUFSIZE])

#define NO_MORE_CHARS (Eof_read && Next >= End_buf)

#define STDIN 0

/******************************************************************************
 * GLOBAL VARIABLES
 ******************************************************************************/

/* The input buffer. */
unsigned char Start_buf[BUFSIZE];

/* Just past the last character. */
unsigned char *End_buf = END;

/* Next input character. */
unsigned char *Next = END;

/* Start of current lexeme. */
unsigned char *sMark = END;

/* End of current lexeme. */
unsigned char *eMark = END;

/* Start of previous lexeme. */
unsigned char *pMark = END;

/* Line # of previous lexeme. */
int pLineno = 0;

/* Length of previous lexeme. */
int pLength = 0;

/* Input file handle. */
int Inp_file = STDIN;

/* Current line number. */
int Lineno = 1;

/* Line # when mark_end() is called. */
int Mline = 1;

/* 
 * Holds the character that was overwritten by \0 when we NUL-terminated
 * the last lexeme.
 */
int  Termchar = 0;

/* 
 * End-of-file has been read. It's possible for this to be true and
 * for characters to still be in the input buffer.
 */
int Eof_read = 0;


/******************************************************************************
 * Functions
 ******************************************************************************/

/**
 * io_newfile
 * ``````````
 * Prepare a new input file for reading.
 *
 * @name: Path to the input file.
 *
 * NOTES
 * If newfile() isn't called before input() or input_line(), then stdin
 * is used. The current input file is closed after successfully opening
 * the new one (but stdin isn't closed).
 *
 * Return -1 if the file can't be opened, otherwise return the file
 * descriptor returned from open(). Note that the old input file won't
 * be closed unless the new file is opened successfully.
 *
 * The error code (errno) generated by the bad open() will still be valid,
 * so you can call perror() to find out what went wrong if you like.
 *
 * At least one free file descriptor must be available when newfile()
 * is called.
 */
int io_newfile(char *name)
{
        int fd; /* File descriptor */        

        if ((fd = (!name) ? STDIN : open(name, O_RDONLY)) != -1) {

                if (Inp_file != STDIN) {
                        close(Inp_file);
                }

                Inp_file = fd;
                Eof_read = 0;

                Next    = END;
                sMark   = END;
                eMark   = END;
                End_buf = END;
                Lineno  = 1;
                Mline   = 1;
        }
        return fd;
}


/******************************************************************************
 * Lexeme access and marker movement. 
 ******************************************************************************/
unsigned char *io_text(void) 
{
        return sMark;
}

int io_length(void) 
{
        return eMark - sMark;
}

int io_lineno(void) 
{
        return Lineno;
}

unsigned char *io_ptext(void) 
{
        return pMark;
}

int io_plength(void) 
{
        return pLength;
}

int io_plineno(void) 
{
        return pLineno;
}


unsigned char *io_mark_start(void)
{
        Mline = Lineno;
        eMark = sMark = Next;

        return sMark;
}


unsigned char *io_mark_end(void)
{
        Mline = Lineno;

        return (eMark = Next);
}


unsigned char *io_move_start(void)
{
        if (sMark >= eMark)
                return NULL;
        else
                return ++sMark;
}


unsigned char *io_to_mark(void)
{
        Lineno = Mline;

        return (Next = eMark);
}


/**
 * io_mark_prev
 * ````````````
 * Set the pMark.
 *
 * CAVEAT
 * Be careful with this routine. A buffer flush won't go past pMark,
 * so once you've set it, you must move it every time you move sMark.
 * I'm not doing this automatically because I might want to remember
 * the token before last rather than the last one. If io_mark_prev()
 * is never called, pMark is just ignored, and you don't have to worry.
 */
unsigned char *io_mark_prev(void)
{
        pMark = sMark;
        pLineno = Lineno;
        pLength = eMark - sMark;

        return pMark;
}


/******************************************************************************
 * STUFF. 
 ******************************************************************************/

/**
 * io_advance
 * ``````````
 * The real input function.
 *
 * NOTES
 * Returns the next character from input and advances past it. The buffer
 * is flushed if the current char is within MAXLOOK chars of the end of the
 * buffer. 0 is returned at EOF. -1 is returned if the buffer can't be flushed
 * because it's too full. In this case you can call io_flush(1) to do a
 * buffer flush but you'll lose the current lexeme as a consequence.
 */
int io_advance(void)
{
        static int been_called = 0;

        /* 
         * Push a newline into the empty buffer so that the LeX start-of-line
         * anchor will work on the first input line.
         */
        if (!been_called) {
                Next = sMark = eMark = END - 1;
                *Next = '\n';
                --Lineno;
                --Mline;
                been_called = 1;
        }

        if (NO_MORE_CHARS)
                return 0;

        if (!Eof_read && io_flush(false) < 0)
                return -1;

        if (*Next == '\n')
                Lineno++;

        return (*Next++);
}


/**
 * io_flush
 * ````````
 * Flush the input buffer.
 *
 * NOTES
 * Do nothing if the current input character isn't in the danger zone,
 * otherwise move all unread characters to the left end of the buffer
 * and fill the remainder of the buffer.
 *
 * Note that input() flushes the buffer willy-nilly if you read past
 * the end of the buffer. Similarly, input_line() flushes the buffer
 * at the beginning of each line.
 *
 *                                               DANGER
 *      Start_buf             sMark   pMark  eMark | Next End_buf
 *       /                         \ /        |    |/     | 
 *      +---------------------------+-------------------+---------+
 *      |       already read        |  yet to be read   | garbage |
 *      +---------------------------+-------------------+---------+
 *
 *      |<------- shift_amt ------->|<---- copy_amt --->|
 *
 *      |<------------------------ BUFSIZE ---------------------->|
 *
 * Either the pMark or sMark (whichever is smaller) is used as the
 * leftmost edge of the buffer. None of the text to the right of the
 * mark will be lost. Return 1 if everything's ok, -1 if the buffer
 * is so full that it can't be flushed. 0 if we're at EOF.
 *
 * If "force" is true, a buffer flush is forced and the characters
 * already in the buffer are discarded. 
 *
 * CAVEAT
 * Don't call this function on a buffer that's been terminated 
 * by io_term().
 */
int io_flush(bool force)
{
        unsigned char *left_edge;
        int copy_amt;
        int shift_amt;

        if (NO_MORE_CHARS)
                return 0;

        if (Eof_read)
                return 1;

        if (Next >= DANGER || force) {
                left_edge = pMark ? min(sMark, pMark) : sMark;
                shift_amt = left_edge - Start_buf;

                /* Not enough room */
                if (shift_amt < MAXLEX) {
                        if (!force)
                                return -1;

                        /* Reset start to current character. */
                        left_edge = io_mark_start();
                        io_mark_prev();

                        shift_amt = left_edge - Start_buf;
                }

                copy_amt = End_buf - left_edge;
                memcpy(Start_buf, left_edge, copy_amt);

                if (!io_fillbuf(Start_buf + copy_amt))
                        e_internal("Buffer full, can't read.\n");

                if (pMark)
                        pMark -= shift_amt;

                sMark -= shift_amt;
                eMark -= shift_amt;
                Next  -= shift_amt;
        }

        return 1;
}


/**
 * io_fillbuf
 * ``````````
 * Fill the input buffer from starting_at to the end of the buffer.
 *
 * NOTES
 * The input file is not clsed when EOF is reached. Buffers are read in
 * units of MAXLEX characters; it's an error if that many characters
 * cannot be read (0 is returned in this case).
 *
 * CAVEAT
 * This function assumes that the read function actually returns the
 * number of characters loaded into the buffer, and that the number will
 * be < need only when the last chunk of the file is read.
 */
int io_fillbuf(unsigned char *starting_at)
{
        register unsigned need; // Number of bytes required from input.
        register unsigned got;  // Number of bytes actually read.

        need = ((END - starting_at) / MAXLEX) * MAXLEX;

        if (need < 0)
                e_internal("Bad read-request starting addr.\n");

        if (need == 0)
                return 0;

        if ((got = read(Inp_file, starting_at, need)) == -1)
                e_internal("Can't read input file.\n");

        End_buf = starting_at + got;

        /* We have reached end of file. */
        if (got < need)
                Eof_read = 1;

        return got;
}


/**
 * io_look
 * ```````
 * Return a lookahead character.
 *
 * @n    : The nth character of lookahead will be the one returned. 
 * Return: the nth character of lookahead, EOF if the nth character
 *         is past end of file, or 0 if nth character is past either 
 *         end of the buffer.
 */
int io_look(int n)
{
        unsigned char *p;

        p = Next + (n-1);

        if (Eof_read && p >= End_buf)
                return EOF;

        return (p < Start_buf || p >= End_buf) ? 0 : *p;
}


/**
 * io_pushback
 * ```````````
 * Push characters back into the input.
 *
 * @n: Number of characters to be pushed back.
 *
 * NOTES
 * You can't push past the current sMark. You can push back characters
 * after the end of file has been encountered.
 */
int io_pushback(int n)
{
        while (--n >= 0 && Next > sMark) {
                if (*--Next == '\n' || !*Next)
                        --Lineno;
        }

        if (Next < eMark) {
                eMark = Next;
                Mline = Lineno;
        }

        return (Next > sMark);
}

/*
 * Support for '\0' terminated strings.
 */
void io_term(void)
{
        Termchar = *Next;
        *Next = '\0';
}

void io_unterm(void)
{
        if (Termchar) {
                *Next = Termchar;
                Termchar = 0;
        }
}

int io_input(void)
{
        int rval;

        if (Termchar) {
                io_unterm();
                rval = io_advance();
                io_mark_end();
                io_term();
        } else {
                rval = io_advance();
                io_mark_end();
        }

        return rval;
}

void io_unput(int c)
{
        if (Termchar) {
                io_unterm();

                if (io_pushback(1)) {
                        *Next = c;
                }

                io_term();
        } else {
                if (io_pushback(1)) {
                        *Next = c;
                }
        }
}

int io_lookahead(int n)
{
        return (n == 1 && Termchar) ? Termchar : io_look(n);
}

int io_flushbuf(void)
{
        if (Termchar)
                io_unterm();

        return io_flush(true);
}

